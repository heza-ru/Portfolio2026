@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {

  /* ── Global Defaults ── */
  *,
  *::before,
  *::after {
    box-sizing: border-box;
  }

  html {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    /* Hide native scrollbar — custom progress bar replaces it */
    scrollbar-width: none;
    -ms-overflow-style: none;
  }

  html::-webkit-scrollbar {
    display: none;
  }

  body {
    @apply bg-[#0A0A0A] text-[#F0EDE8] overflow-x-hidden;
    font-family: 'Satoshi', sans-serif;
    cursor: none;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }

  /* Restore cursor on touch/hover:none devices */
  @media (hover: none) {
    body {
      cursor: auto;
    }
  }

  /*
   * Respect prefers-reduced-motion.
   * Don't use !important on transition-duration across the board — it
   * breaks GSAP's own duration values. Instead kill CSS animations and
   * transitions only; GSAP reads this media query separately.
   */
  @media (prefers-reduced-motion: reduce) {
    *,
    *::before,
    *::after {
      animation-duration: 0.001ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.001ms !important;
      scroll-behavior: auto !important;
    }
  }

  /*
   * Use contain:style (not layout/paint) on sections.
   * - contain:layout would prevent GSAP ScrollTrigger from measuring
   *   element offsets relative to the document correctly.
   * - contain:paint clips overflow, which is intentional per section.
   *   But we exclude it here so GSAP pinning doesn't cause visual clipping.
   * - contain:style is safe: it stops CSS counters / custom properties
   *   from leaking between sections with negligible cost.
   */
  section {
    contain: style;
  }

  /* Lazy-decode images — avoids blocking the main thread on decode */
  img {
    max-width: 100%;
    height: auto;
    display: block;
    content-visibility: auto;
  }
}

@layer utilities {

  /* Clip-path helper used in the Navbar takeover */
  .clip-circle-none {
    clip-path: circle(0% at 50% 50%);
  }

  .clip-circle-full {
    clip-path: circle(150% at 50% 50%);
  }

  /* ── Magnetic Buttons (Slide & Scale) ── */
  .btn-magnetic {
    position: relative;
    overflow: hidden;
    /*
     * will-change only during hover, not permanently.
     * Permanent will-change on small elements wastes GPU memory.
     * We let the hover state trigger layer promotion via :hover.
     */
    transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }

  .btn-magnetic:hover {
    transform: scale(1.03);
    will-change: transform;
  }

  /* Sliding background span inside .btn-magnetic */
  .btn-magnetic > .bg-slider {
    position: absolute;
    inset: 0;
    transform: translateY(100%);
    transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    z-index: 0;
  }

  .btn-magnetic:hover > .bg-slider {
    transform: translateY(0);
  }

  /* Ensure text sits above the sliding background */
  .btn-magnetic > .btn-text {
    position: relative;
    z-index: 10;
  }

  /* ── Link Lift ── */
  .link-lift {
    display: inline-block;
    transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }

  .link-lift:hover {
    transform: translateY(-2px);
  }

  /* ── Pixel Reveal ── */
  .pixel-reveal-wrap {
    position: relative;
    overflow: hidden;
  }

  .pixel-reveal-wrap > div:last-child {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 10;
    overflow: hidden;
  }

  /* ── Digital Grid Overlay Effect ── */
  .digital-grid-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    z-index: 9998;
    overflow: hidden;
    /*
     * contain:strict on the overlay itself is fine — it's a fixed overlay
     * with no children that need to be measured externally.
     */
    contain: strict;
  }

  .digital-grid-block {
    position: absolute;
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #0A0A0A;
    color: #F0EDE8;
    font-family: 'Courier New', 'Courier', monospace;
    font-size: 19px;
    font-weight: 600;
    line-height: 1;
    opacity: 0;
    /*
     * Transition only opacity — compositor-only property (S-Tier).
     * No transform: translateZ(0) here: applying it to 1600+ blocks
     * simultaneously creates a GPU layer per block and blows out
     * VRAM on any device. The parent overlay is already its own layer.
     */
    transition: opacity 0.12s cubic-bezier(0.4, 0, 0.2, 1);
    text-shadow: 0 0 10px rgba(240, 237, 232, 0.6);
    -webkit-font-smoothing: antialiased;
    contain: strict;
  }

  .digital-grid-block.active {
    opacity: 0.88;
  }

  @media (prefers-reduced-motion: reduce) {
    .digital-grid-block {
      transition: none;
      animation: none;
    }
  }

  /* ── Custom Cursor ── */
  [data-cursor] {
    cursor: none;
    -webkit-tap-highlight-color: transparent;
  }
}
